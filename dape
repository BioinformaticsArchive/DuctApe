#!/usr/bin/python
"""
DuctApe

Analyze genome(s) and phenome(s)
"""
from ductape import __version__
from ductape.actions import touchProject
from ductape.common.colorlog import ColorFormatter
from ductape.storage.SQLite.database import Organism, Project, Kegg, Biolog
# TODO: handle this imports somewhere else
from matplotlib import cm
import argparse
import logging.handlers
import os

__author__ = "Marco Galardini"
__prog__ = "dape"

################################################################################
# Log setup

logger = logging.getLogger('ductape')

################################################################################
# Methods

def dinit(options, wdir, project):
    from ductape.actions import dInit
    if not dInit(project, wdir, options.name, options.descr):
        logger.warning('You can remove or rename the old project file')
        return False
    else:
        return True

def dadd(options, wdir, project):
    from ductape.actions import dAdd
    if not touchProject(project):
        logger.warning('You can setup a new project by running %s init'%
                       __prog__)
        return False
    return dAdd(project, options.orgID, options.n, options.d, options.c)

def daddMut(options, wdir, project):
    from ductape.actions import dMutAdd
    if not touchProject(project):
        logger.warning('You can setup a new project by running %s init'%
                       __prog__)
        return False
    return dMutAdd(project, options.mutID, options.m,
                     options.k, options.n, options.d, options.c)

def dstart(options, wdir, project):
    from ductape.kegg.kegg import KeggNet
    from ductape.terminal import RunThread
    
    if not touchProject(project):
        logger.warning('You can setup a new project by running %s init'%
                       __prog__)
        return False
    
    logger.info('Fetching the whole KEGG metabolic map')
    kegg = Kegg(project)
    avoid = [kid for kid in kegg.getAllIDs()]
    
    knet = KeggNet(avoid=avoid)
    if not RunThread(knet):
        return False
    
    # Details
    kegg.addPathways(knet.result.path)
    logger.info('Added %d Path IDs'%len(knet.result.path))
    kegg.addReactions(knet.result.react)
    logger.info('Added %d Re IDs'%len(knet.result.react))
    kegg.addCompounds(knet.result.comp)
    logger.info('Added %d Co IDs'%len(knet.result.comp))
    kegg.addRPairs(knet.result.rpair)
    logger.info('Added %d RPair IDs'%len(knet.result.rpair))
    # Links
    kegg.addPathReacts(knet.result.pathreact)
    kegg.addReactComps(knet.result.reactcomp)
    kegg.addCompReacts(knet.result.compreact)
    kegg.addPathComps(knet.result.pathcomp)
    kegg.addReactRPairs(knet.result.reactrpair)
    kegg.addRPairReacts(knet.result.rpairreact)
    logger.info('Added Kegg links')
    # HTML maps
    kegg.addPathHtml(knet.result.pathmaps)
    logger.info('Added Kegg maps')
    
    return True

def dmap(options, wdir, project):
    from ductape.actions import dSetKind, getPathsReacts, getPathsComps
    from ductape.actions import prepareColors, createLegend
    from ductape.kegg.kegg import KeggColor, MapsFetcher
    from ductape.terminal import RunThread
    from ductape.common.utils import rgb_to_hex
    from itertools import combinations
    import numpy as np
    
    if not touchProject(project):
        logger.warning('You can setup a new project by running %s init'%
                       __prog__)
        return False
    
    # Check which maps we have to generate
    # Genome
    proj = Project(project)
    proj.getProject()
    if proj.genome != 'map2kegg':
        logger.warning('Genome mapping to KEGG has not yet been performed!')
    
    # Phenome
    biolog = Biolog(project)
    if biolog.atLeastOneNoParameter():
        logger.warning('Phenome parametrization has not yet been performed!')
        phenome = False
    else:
        phenome = True
    if phenome and options.s:
        phenome = False
        logger.warning('Skipping the phenomic data')
    
    kegg = Kegg(project)
    
    kind = dSetKind(project)
    
    rpaths = getPathsReacts(project)
    cpaths = getPathsComps(project)
    
    if len(options.organisms) == 0:
        # PanGenome or all genomes?
        if kind != 'mutants' and options.all:
            logger.info('Going to generate all the single genomic maps')
            
            organism = Organism(project)
            for org_id in [x.org_id for x in organism.getAll()]:
                logger.info('Going to generate the metabolic map for %s'%org_id)
                
                # Create the legend
                legend = createLegend('single')
                
                if phenome:
                    logger.info('Generating the reactions-only map')
                if not doFetchMaps(project, org_id, rpaths, cpaths, legend):
                    return False
                
                if phenome:
                    for categ in biolog.getCategs():
                        logger.info('Plotting maps for biolog category %s'%categ.category)
                        if not doFetchMaps(project, org_id, rpaths, cpaths, legend,
                                           categ.category.replace(' ','_').replace('&','and')):
                            return False
                
        elif proj.isPanGenome() and kind == 'pangenome':
            logger.info('Going to generate a pangenomic metabolic map')
            
            # Some info
            logger.info('Single genome maps can be created using %s map orgID1 orgID2 ...'%
                        __prog__)
            logger.info('All the single genome maps can be created using %s map -a'%
                        __prog__)
            
            # Get the reactions in the pangenome space
            core = {}
            for cR in kegg.getCoreReact():
                core[cR.re_id] = cR.num
            
            disp = {}
            for cR in kegg.getDispensableReact():
                disp[cR.re_id] = cR.num
                
            # Get the intersected reactions
            mix_id = set(core.keys()).intersection(set(disp.keys()))
            mix = {}
            for re_id in mix_id:
                mix[re_id] = core[re_id] + disp[re_id]
            for re_id in mix_id:
                del core[re_id]
                del disp[re_id]
            
            # Go for the colors!
            # Mix
            if len(mix.values()) == 0:
                hexmix = {}
            else:
                hexmix = prepareColors(max(mix.values()), cm.Greens(np.arange(85,256)))
            
            # Core
            if len(core.values()) == 0:
                hexcore = {}
            else:
                hexcore = prepareColors(max(core.values()), cm.Blues(np.arange(85,256)))
                
            # Dispensable
            if len(disp.values()) == 0:
                hexdisp = {}
            else:
                hexdisp = prepareColors(max(disp.values()), cm.Oranges(np.arange(85,256)))
            
            # Create the legend
            legend = createLegend('pangenome')
            
            if phenome:
                logger.info('Generating the reactions-only map')
            # Create the input objects
            colorPaths = []
            for path in rpaths:
                KC = KeggColor(path)
                dreact = {}
                for re_id in rpaths[path]:
                    if re_id in mix:
                        dreact[re_id] = hexmix[mix[re_id]]
                    elif re_id in core:
                        dreact[re_id] = hexcore[core[re_id]]
                    elif re_id in disp:
                        dreact[re_id] = hexdisp[disp[re_id]]
                    else:
                        dreact[re_id] = '#FFFFFF'
                KC.setReactions(dreact)
                KC.setMap(kegg.getPathway(path).html)
                colorPaths.append(KC)
                
            # Go!
            kmap = MapsFetcher(colorPaths, prefix='pangenome', legend=legend)
    
            if not RunThread(kmap):
                return False
            
            logger.info('%d maps are available in %s'%(len(kmap.pics),
                                                       kmap._keggroom))
            
            if phenome:
                for categ in biolog.getCategs():
                    logger.info('Plotting maps for biolog category %s'%categ.category)
                    logger.info(
                            'Showing average differences in the activity >= %d'%options.delta)
                    
                    # Get the compounds in the phenomics space
                    corg = {}
                    wells = [w for w in biolog.getAllCoByCateg(categ.category)]
                    for well in wells:
                        acts = [x.avgact 
                                for x in
                                biolog.getAvgActivityEachOrg(well.plate_id,
                                                             well.well_id)]
                        if len(acts) <= 1:
                            continue
                        
                        diffs = []
                        for a, a1 in combinations(acts, 2):
                            diffs.append( abs(a - a1) )
                        avgdiff = np.array(diffs).mean()
                        if avgdiff < options.delta:continue
                        
                        # Some co_ids are present more than once
                        if well.co_id not in corg:
                            corg[well.co_id] = []
                        corg[well.co_id].append(avgdiff)
                    
                    toremove = set()
                    for k, v in corg.iteritems():
                        mean = np.array(v).mean()
                        if mean != np.nan:
                            corg[k] = mean
                        else:
                            toremove.add(k)
                    for k in toremove:
                        del corg[k]
                    
                    if len(corg) == 0:
                        logger.warning('No compounds available for category %s'%(categ.category))
                        continue
                    
                    # Create the input objects
                    colorPaths = []
                    for path in set(rpaths.keys() + cpaths.keys()):
                        KC = KeggColor(path)
                        
                        dreact = {}
                        if path in rpaths:
                            for re_id in rpaths[path]:
                                if re_id in mix:
                                    dreact[re_id] = hexmix[mix[re_id]]
                                elif re_id in core:
                                    dreact[re_id] = hexcore[core[re_id]]
                                elif re_id in disp:
                                    dreact[re_id] = hexdisp[disp[re_id]]
                                else:
                                    dreact[re_id] = '#FFFFFF'
                        
                        dcomp = {}            
                        if path in cpaths:
                            for co_id in cpaths[path]:
                                if co_id.lstrip('cpd:') in corg:
                                    # We map the values 0-9 in a 85-256 window
                                    numcolor = int((corg[co_id.lstrip('cpd:')]*171)/9) + 85
                                    color = cm.Purples( numcolor )[:3]
                                    color = tuple([int(round(x*255)) for x in color])
                                    dcomp[co_id] = rgb_to_hex(color).upper()
                                else:
                                    dcomp[co_id] = '#FFFFFF'
                        
                        KC.setReactions(dreact)
                        KC.setCompounds(dcomp)
                        KC.setMap(kegg.getPathway(path).html)
                        colorPaths.append(KC)
                        
                    # Go!
                    prefix = 'pangenome_'+categ.category.replace(' ','_').replace('&','and')
                    kmap = MapsFetcher(colorPaths, prefix=prefix, legend=legend)
            
                    if not RunThread(kmap):
                        return False
                    
                    logger.info('%d maps are available in %s'%(len(kmap.pics),
                                                               kmap._keggroom))
                
        elif kind == 'single':
            logger.info('Going to generate a genomic metabolic map')
            
            organism = Organism(project)
            org_id = [x.org_id for x in organism.getAll()][0]
            
            # Create the legend
            legend = createLegend('single')
            
            if phenome:
                logger.info('Generating the reactions-only map')
            if not doFetchMaps(project, org_id, rpaths, cpaths, legend):
                return False
            
            if phenome:
                for categ in biolog.getCategs():
                    logger.info('Plotting maps for biolog category %s'%categ.category)
                    if not doFetchMaps(project, org_id, rpaths, cpaths, legend,
                                       categ.category.replace(' ','_').replace('&','and')):
                        return False                
        
        elif kind == 'mutants':
            logger.info('Going to generate mutants metabolic map')
        
            organism = Organism(project)
        
            refs = [org.org_id
                    for org in organism.getAll()
                    if not organism.isMutant(org.org_id)]
        
            for ref_id in refs:
                logger.info('Going to generate the metabolic map for reference %s'%
                            ref_id)
                
                # Create the legend
                legend = createLegend('single')
                
                if phenome:
                    logger.info('Generating the reactions-only map')
                if not doFetchMaps(project, ref_id, rpaths, cpaths, legend):
                    return False
                
                if phenome:
                    for categ in biolog.getCategs():
                        logger.info('Plotting maps for biolog category %s'%categ.category)
                        if not doFetchMaps(project, ref_id, rpaths, cpaths, legend,
                                           categ.category.replace(' ','_').replace('&','and')):
                            return False
                
                muts = [x for x in organism.getOrgMutants(ref_id)]
                for mut_id in muts:
                    logger.info('Going to generate the metabolic map for mutant %s (parent %s)'%
                            (mut_id,ref_id))
                    
                    # Get the reactions in the mutant space
                    mut = {}
                    for mR in kegg.getOrgReact(mut_id):
                        mut[mR.re_id] = mR.num
                    
                    ref = {}
                    for rR in kegg.getReferenceReact(mut_id, ref_id):
                        ref[rR.re_id] = rR.num
                    
                    # Get the intersected reactions
                    mix_id = set(mut.keys()).intersection(set(ref.keys()))
                    mix = {}
                    for re_id in mix_id:
                        mix[re_id] = ref[re_id] + mut[re_id]
                    for re_id in mix_id:
                        del mut[re_id]
                        del ref[re_id]
                    
                    # Go for the colors!
                    # Mix
                    if len(mix.values()) == 0:
                        hexmix = {}
                    else:
                        hexmix = prepareColors(max(mix.values()), cm.copper_r(np.arange(1,170)))
                    
                    # mut
                    if len(mut.values()) == 0:
                        hexmut = {}
                    else:
                        hexmut = prepareColors(max(mut.values()), cm.Reds(np.arange(85,256)))
                        
                    # ref
                    if len(ref.values()) == 0:
                        hexref = {}
                    else:
                        hexref = prepareColors(max(ref.values()), cm.Greens(np.arange(85,256)))
                    
                    # Create the legend
                    legend = createLegend('mutants')
                    
                    if phenome:
                        logger.info('Generating the reactions-only map')
                    
                    # Create the input objects
                    colorPaths = []
                    for path in rpaths:
                        KC = KeggColor(path)
                        dreact = {}
                        for re_id in rpaths[path]:
                            if re_id in mix:
                                dreact[re_id] = hexmix[mix[re_id]]
                            elif re_id in mut:
                                dreact[re_id] = hexmut[mut[re_id]]
                            elif re_id in ref:
                                dreact[re_id] = hexref[ref[re_id]]
                            else:
                                dreact[re_id] = '#FFFFFF'
                        KC.setReactions(dreact)
                        KC.setMap(kegg.getPathway(path).html)
                        colorPaths.append(KC)
                        
                    # Go!
                    kmap = MapsFetcher(colorPaths, prefix=mut_id, legend=legend)
            
                    if not RunThread(kmap):
                        return False
                    
                    logger.info('%d maps are available in %s'%(len(kmap.pics),
                                                               kmap._keggroom))
                    
                    if phenome:
                        for categ in biolog.getCategs():
                            logger.info('Plotting maps for biolog category %s'%categ.category)
                            logger.info('Showing differences in the activity >= %d'%options.delta)                            # Get the compounds in the phenomics space
                            corg = {}
                            wells = [w for w in biolog.getAllCoByCateg(categ.category)]
                            for well in wells:
                                mact = biolog.getAvgActivity(well.plate_id, well.well_id, mut_id)
                                ract = biolog.getAvgActivity(well.plate_id, well.well_id, ref_id)
                                if mact and ract:
                                    diff = ract - mact
                                    if abs(diff) < options.delta:continue
                                    # Some co_ids are present more than once
                                    if well.co_id not in corg:
                                        corg[well.co_id] = []
                                    corg[well.co_id].append(diff)
                            
                            toremove = set()
                            for k, v in corg.iteritems():
                                mean = np.array(v).mean()
                                if mean != np.nan or abs(diff) >= options.delta:
                                    corg[k] = mean
                                else:
                                    toremove.add(k)
                            for k in toremove:
                                del corg[k]
                            
                            if len(corg) == 0:
                                logger.warning('No compounds available for category %s (%s)'%(categ.category, mut_id))
                                continue
                            
                            # Create the input objects
                            colorPaths = []
                            for path in set(rpaths.keys() + cpaths.keys()):
                                KC = KeggColor(path)
                                
                                dreact = {}
                                if path in rpaths:
                                    for re_id in rpaths[path]:
                                        if re_id in mix:
                                            dreact[re_id] = hexmix[mix[re_id]]
                                        elif re_id in mut:
                                            dreact[re_id] = hexmut[mut[re_id]]
                                        elif re_id in ref:
                                            dreact[re_id] = hexref[ref[re_id]]
                                        else:
                                            dreact[re_id] = '#FFFFFF'
                                
                                dcomp = {}            
                                if path in cpaths:
                                    for co_id in cpaths[path]:
                                        if co_id.lstrip('cpd:') in corg:
                                            # We map the values 0-9 in a 0-256 window
                                            numcolor = int((corg[co_id.lstrip('cpd:')]*256)/9)
                                            color = cm.PuOr( numcolor )[:3]
                                            color = tuple([int(round(x*255)) for x in color])
                                            dcomp[co_id] = rgb_to_hex(color).upper()
                                        else:
                                            dcomp[co_id] = '#FFFFFF'
                                
                                KC.setReactions(dreact)
                                KC.setCompounds(dcomp)
                                KC.setMap(kegg.getPathway(path).html)
                                colorPaths.append(KC)
                                
                            # Go!
                            prefix = mut_id+'_'+categ.category.replace(' ','_').replace('&','and')
                            kmap = MapsFetcher(colorPaths, prefix=prefix, legend=legend)
                    
                            if not RunThread(kmap):
                                return False
                            
                            logger.info('%d maps are available in %s'%(len(kmap.pics),
                                                                       kmap._keggroom))
        else:
            logger.warning('Unattended case %s'%kind)
            
    else:
        orgs = set(options.organisms)
        
        organism = Organism(project)
        
        for org_id in orgs:
            if not organism.isOrg(org_id):
                logger.warning('Organism %s is not present: skipping'%org_id)
                continue
            
            logger.info('Going to generate the metabolic map for %s'%org_id)
            
            # Create the legend
            legend = createLegend('single')
            
            if phenome:
                logger.info('Generating the reactions-only map')
            if not doFetchMaps(project, org_id, rpaths, cpaths, legend):
                return False
            if phenome:
                for categ in biolog.getCategs():
                    logger.info('Plotting maps for biolog category %s'%categ.category)
                    if not doFetchMaps(project, org_id, rpaths, cpaths, legend,
                                       categ.category.replace(' ','_').replace('&','and')):
                        return False

def dremove(options, wdir, project):
    from ductape.actions import dRemove
    if not touchProject(project):
        logger.warning('Nothing to be removed!\n'+
                       'You can setup a new project by running %s init'%
                       __prog__)
        return False
    return dRemove(project, options.organisms)

def dclear(options, wdir, project):
    from ductape.actions import dClear
    if not touchProject(project):
        logger.warning('Nothing to be cleaned up!\n'+
                       'You can setup a new project by running %s init'%
                       __prog__)
        return False
    return dClear(project)

def doFetchMaps(project, org_id, rpaths, cpaths, legend=None, category=None):
    from ductape.actions import prepareColors
    from ductape.kegg.kegg import KeggColor, MapsFetcher
    from ductape.terminal import RunThread
    from ductape.common.utils import rgb_to_hex
    import numpy as np
    
    kegg = Kegg(project)
    biolog = Biolog(project)
    
    # Get the reactions in the organism space
    rorg = {}
    for oR in kegg.getOrgReact(org_id):
        rorg[oR.re_id] = oR.num
        
    # Get the compounds in the phenomics space
    corg = {}
    if category:
        wells = [w for w in biolog.getAllCoByCateg(category)]
    else:
        wells = []
    for well in wells:
        act = biolog.getAvgActivity(well.plate_id, well.well_id, org_id)
        if act:
            # Some co_ids are present more than once
            if well.co_id not in corg:
                corg[well.co_id] = []
            corg[well.co_id].append(act)
    
    toremove = set()
    for k, v in corg.iteritems():
        mean = np.array(v).mean()
        if mean != np.nan:
            corg[k] = mean
        else:
            toremove.add(k)
    for k in toremove:
        del corg[k]
        
    if category and len(corg) == 0:
        logger.warning('No compounds available for category %s (%s)'%(category, org_id))
        return True
    
    # Go for the colors (reactions)!
    rhexorg = prepareColors(max(rorg.values()), cm.Greens(np.arange(85,256)))
     
    # Create the input objects
    colorPaths = []
    for path in set(rpaths.keys() + cpaths.keys()):
        KC = KeggColor(path)
        
        # Reactions
        dreact = {}
        if path in rpaths:
            for re_id in rpaths[path]:
                if re_id in rorg:
                    dreact[re_id] = rhexorg[rorg[re_id]]
                else:
                    dreact[re_id] = '#FFFFFF'
                    
        # Compounds
        dcomp = {}
        if path in cpaths:
            for co_id in cpaths[path]:
                if co_id.lstrip('cpd:') in corg:
                    # We map the values 0-9 in a 0-256 window
                    numcolor = int((corg[co_id.lstrip('cpd:')]*256)/9)
                    color = cm.RdYlGn( numcolor )[:3]
                    color = tuple([int(round(x*255)) for x in color])
                    dcomp[co_id] = rgb_to_hex(color).upper()
                else:
                    dcomp[co_id] = '#FFFFFF'
        
        KC.setReactions(dreact)
        KC.setCompounds(dcomp)
        KC.setMap(kegg.getPathway(path).html)
        colorPaths.append(KC)
        
    # Go!
    if category:
        prefix = org_id + '_' + category
    else:
        prefix = org_id
    kmap = MapsFetcher(colorPaths, prefix=prefix, legend=legend)

    if not RunThread(kmap):
        return False
    
    logger.info('%d maps are available in %s'%(len(kmap.pics), kmap._keggroom))
    
    return True

################################################################################
# Options

def getOptions():
    description = "Analyze genomes & phenomes"
    parser = argparse.ArgumentParser(description = description,
                                     prog=__prog__)
    parser.add_argument('-p', metavar='project', action='store',
                        dest='project',
                        default='ductape.db',
                        help='Project file')
    parser.add_argument('-w', metavar='workdir', action='store', dest='wdir',
                        default='.',
                        help='Working directory')
    parser.add_argument('-v', action='count',
                        default=0,
                        help='Increase verbosity level')
    parser.add_argument('--version', action='version',
                        version='%(prog)s '+__version__)
    subparsers = parser.add_subparsers()

    parser_init = subparsers.add_parser('init', help='Initialize the project')
    parser_init.add_argument('-n', action="store",
                             dest='name',
                             default = 'Project',
                             help='Project name')
    parser_init.add_argument('-d', metavar='descr', action="store",
                            dest='descr',
                            default = 'DuctApe project',
                            help='Project description')
    parser_init.set_defaults(func=dinit)
    
    parser_add = subparsers.add_parser('add',
                           help='Add an organism')
    parser_add.add_argument('orgID', action='store',
                            help='Organism ID')
    parser_add.add_argument('-n', metavar='name', action="store",
                            default = '',
                            help='Organism name')
    parser_add.add_argument('-d', metavar='descr', action="store",
                            default = '',
                            help='Organism description')
    parser_add.add_argument('-c', metavar='color', action="store",
                            default = '',
                            help='Organism color')
    parser_add.set_defaults(func=dadd)
    
    parser_add_mut = subparsers.add_parser('add-mut',
                               help='Add a mutant of an existing organism')
    parser_add_mut.add_argument('mutID', action='store',
                            help='Mutant organism ID')
    parser_add_mut.add_argument('-m', metavar='mutparent', action="store",
                            required = True,
                            help='This mutant parent orgID')
    parser_add_mut.add_argument('-k', metavar='kind', action="store",
                            choices = ['deletion', 'insertion'],
                            default = 'deletion',
                            help='This mutant kind (deletion|insertion)')
    parser_add_mut.add_argument('-n', metavar='name', action="store",
                            default = '',
                            help='Organism name')
    parser_add_mut.add_argument('-d', metavar='descr', action="store",
                            default = '',
                            help='Organism description')
    parser_add_mut.add_argument('-c', metavar='color', action="store",
                            default = '',
                            help='Organism color')
    parser_add_mut.set_defaults(func=daddMut)
    
    parser_start = subparsers.add_parser('start', help='Start the analysis')
    parser_start.set_defaults(func=dstart)
    
    parser_map = subparsers.add_parser('map', help='Fetch metabolic maps')
    parser_map.add_argument('-a', '--all', action="store_true",
                            default=False,
                            help='Plot all the single organisms maps')
    parser_map.add_argument('-d', metavar='delta', action="store", dest='delta',
                              type=int,
                              default=3,
                              help='Activity delta threshold')
    parser_map.add_argument('-s', action="store_true",
                            default=False,
                            help='Skip the phenomic data')
    parser_map.add_argument('organisms', metavar='orgID', nargs='*',
                            action="store",
                            default=[],
                            help='Organism(s) to be mapped')
    parser_map.set_defaults(func=dmap)
    
    parser_rm = subparsers.add_parser('rm', help='Completely remove an organism')
    parser_rm.add_argument('organisms', metavar='orgID', nargs='+',
                              action="store",
                            help='Organism(s) to be removed')
    parser_rm.set_defaults(func=dremove)
    
    parser_clear = subparsers.add_parser('clear',
                                         help='Clear all the results')
    parser_clear.set_defaults(func=dclear)
    
    return parser.parse_args()

################################################################################

options = getOptions()

logger.setLevel(logging.DEBUG)

ch = logging.StreamHandler()
if options.v == 0:
    ch.setLevel(logging.INFO)
elif options.v >= 1:
    ch.setLevel(logging.DEBUG)
formatter = ColorFormatter('%(asctime)s - $COLOR%(message)s$RESET','%H:%M:%S')
ch.setFormatter(formatter)
logger.addHandler(ch)

fh = logging.handlers.RotatingFileHandler('ductape.log', maxBytes=2000000)
formatter = logging.Formatter('%(asctime)s - %(name)s - [%(levelname)s] - %(message)s',
                            '%Y-%m-%d %H:%M:%S')
fh.setFormatter(formatter)
logger.addHandler(fh)

wdir = os.path.abspath(options.wdir)
if not os.path.exists(wdir):
    try:
        os.mkdir(wdir)
    except:
        logger.error('Could not create working directory %s'%wdir)
    
project = os.path.join(wdir, options.project)

options.func(options, wdir, project)

touchProject(project)
